---
layout: default
title: ZEP0006
description: Zarr Object Models (ZOMs)
parent: draft ZEPs
nav_order: 6
---

# ZEP 6 - A Zarr Object Model

Authors:

* Davis Bennett([@d-v-b](https://github.com/d-v-b))

Status: Draft

Type: Specification

Created: 2023-07-20


## Abstract

When working with N-dimensional array data, the arrangement of groups and arrays into a tree or hierarchy often conveys useful information about the data set. Using the abstract data model described in the [Zarr core specification](https://zarr-specs.readthedocs.io/en/latest/v3/core/v3.0.html), it is possible to describe Zarr hierarchies through narrative description or graphical depiction. However, there is currently no standard, machine-readable way to describe a particular hierarchy configuration, nor to identify the set of hierarchy configurations that an application permits. To address this gap, this proposal offers standards for implementing the Zarr abstract data model in JSON and JSON Schema. This proposal uses several formal concepts that are already defined in the Zarr core specification--arrays, groups, and attributes--and introduces a new concept, members. The guidelines presented here could be readily adapted to represent Zarr hierarchies in a variety of interchange formats. These representations can used by applications in a declarative, type-safe approach to managing Zarr hierarchies, independent of the actual array data.

## Motivation and Scope

The Zarr specifications define models for arrays and groups, but do not define models for *hierarchies* of arrays and groups. Nevertheless, many applications perform tasks on the level of structured hierarchies rather than individual groups or arrays. Such tasks include evaluating whether two Zarr hierarchies are identically structured, evaluating whether a given Zarr hierarchy has a specific structure, or creating a new Zarr hierarchy with a desired structure. 

For example, the python library `xarray` defines data structures that can be persisted to Zarr as a Zarr group containing one or more Zarr arrays with specific metadata (a key called "_ARRAY_DIMENSIONS", which must have a list of strings as its value). The full specification of this format can be found [here](https://docs.xarray.dev/en/stable/internals/zarr-encoding-spec.html#zarr-encoding). For `xarray` (or any other application that works with structured hierarchies) to save data to Zarr, it must first create a compliant Zarr hierarchy. To read data from Zarr, `xarray` must first check if the potential source of data is an `xarray`-compliant Zarr hierarchy. 

These actions access Zarr hierarchies, not individual arrays or groups. Accessing Zarr hierarchies can be done procedurally, i.e. as a sequence of Zarr array and group access routines, or declaratively, as a hierarchy definition followed by a procedure that implements or manipulates that definition. The latter is simpler, but a declarative hierarchy API requires defining data models for Zarr hierarchies. This is the central goal of this document.

## Definitions

The [core Zarr specification](https://zarr-specs.readthedocs.io/en/latest/v3/core/v3.0.html) defines a hierarchy as a tree structure where each node in the tree is either a group or an array. Arrays and groups are associated with distinct metadata objects, each containing particular metadata keys. For more complete definitions of these terms and concepts, refer to the Zarr core specification.

This document distinguishes the *structure* of a Zarr hierarchy from the array data stored in the hierarchy. The structure of a Zarr hierarchy is the layout of the tree of arrays and groups. (Note: we use the terms "structure" and "configuration" interchangeably.) This proposal is mainly concerned with hierarchy structure, and also references group and array metadata. It is not concerned with the data stored in the arrays, nor with the particular storage backend. Accordingly, two distinct Zarr hierarchies can have the same structure even if their arrays contain different values, and/or the hierarchies are stored using different storage backends.

We introduce the new term, `members`, which refers to nodes *directly* (one level) below a particular group. Only a group can have members. Thus, member is a role that arises from context, and is not a type of node. 

## Specification of the base Zarr Object Model

We begin with a definition of a "base" Zarr Object Model. On its own, the base ZOM is not useful for working with actual Zarr hierarchies, because it contains a reference to an unspecified Zarr version. By supplying definitions from a particular Zarr version, we can specialize the base ZOM and produce an object that can be used for doing actual work. 

A node is an object with a property called `attributes`, which is a key-value data structure that contains content described as "arbitrary user metadata" in Zarr specifications. As of Zarr versions 2 and 3, `attributes` must be a JSON-serializable object with string keys.

The base ZOM defines exactly two types of node: groups and arrays. This definition will use the unqualified terms "array" and "group" to refer to the two nodes defined in the ZOM. Where necessary to avoid ambiguity, the objects *represented* by ZOM arrays and ZOM groups, i.e. Zarr arrays and Zarr groups, will be referred to as "Zarr arrays" and "Zarr groups".

ZOM arrays and ZOM groups represent Zarr arrays and Zarr groups in the simplest way possible that still conforms to the definition of "node" given above. Thus, a ZOM array is a node with properties identical to those defined in a particular specification of Zarr array metadata, unless one of those Zarr array properties contains user metadata, in which case a ZOM array does not include that property (since user metadata is already represented by the `attributes` property of the array). This definition is parametric with respect to a particular Zarr specification in order to accomodate future versions of Zarr that may add new properties to Zarr arrays.

Similarly, a ZOM group is a node with properties identical to those defined in a specification of Zarr group metadata, unless one of those properties contains user metadata, in which case a ZOM group does not contain that property, for the same reason given above for arrays. Beyond the properties of Zarr groups defined in a particular Zarr specification, a ZOM group has an additional property:

- `members`: a key-value data structure where the keys are the subset of strings that are permitted node names according to a particular Zarr specification, and the values are arrays or groups. This property allows a ZOM group to represent the hierarchical relationship between Zarr groups and the Zarr arrays or Zarr groups contained within them.

If future versions of Zarr use a property called `members` for some element of Zarr group metadata, then there would be a naming collision between the `members` property of a Zarr group and the `members` property of a ZOM group. In this case, the ZOM group would rename the Zarr group's `members` property to `_members`, and any additional name collisions would be resolved by prepending additional underscore ("_") characters. E.g., in the unlikely case that `members` and `_members` are *both* listed in Zarr group metadata, then the schema group representation would map the `members` property of the Zarr group to a property called `__members`.

Thus, ZOM groups and ZOM arrays can represent the structure of a Zarr hierarchy, per the description given in [#definition-of-hierarchy-structure].

## Modeling Zarr hierarchy structures in JSON

To model a Zarr hierarchy structure, we begin by representing Zarr arrays and Zarr groups as simple, fairly abstract objects--in this case, we will use JSON objects.

Let's start with arrays. We will represent a single array as a JSON object containing metadata identical to the metadata for the actual array we wish to represent. This decision has the advantage that whatever process is validating the hierarchy structure can also validate the array metadata. In other words, the process can check that arrays with the proper characteristics appear in the proper locations. The precise metadata keys will vary with the Zarr version used. 

In this way, we could represent a single array (in Zarr v.2) like so:

```json
{
  "foo": {
    "zarr_format" : 2,
    "shape" : [10,10],
    "chunks": [1,1],
    "dtype": "|u1",
    "compressor": null,
    "fill_value": 0,
    "order": "C",
    "filters": null,
    "attributes" : {
      "name": "my cool array"
      }
}
```

Note that in the Zarr core specification, array metadata structures and/or group metadata structures may contain a property called `attributes`, which holds arbitrary user metadata. In actual Zarr metadata as well as in our node representations here, user metadata should be stored in `attributes`, not as new properties in the metadata object.

Next, we can represent a group node as an object with the exact same properties as the actual group's metadata. For instance:

```json
{
  "zarr_format" : 2,
  "attributes": {
    "foo" : 10, 
    "bar" : "hello"
    }
}
```

To represent the links between nodes, we introduce a new property, for group nodes only: 

- `members`: a key-value data structure where the keys are strings and the values are objects representing either arrays or groups.

Since arrays cannot have child nodes by definition, our array representations must never contain the `members` property. Meanwhile, objects representing groups that have child nodes must contain the `members` property.

Putting together these components, let's create a JSON representation of a Zarr v.3 hierarchy consisting of one group that contains a single two-dimensional Zarr array. Both the Zarr group and the Zarr array contain user metadata.

```json
{
  "zarr_format": 3,
  "node_type": "group",
  "attributes": {
    "foo": 42,
    "bar": false
  },
  "members": {
    "array": {
      "zarr_format": 3,
      "node_type": "array",
      "attributes": {
        "baz": [
          1,
          2,
          3
        ]
      },
      "shape": [
        1000,
        1000
      ],
      "data_type": "|u1",
      "chunk_grid": {
        "name": "regular",
        "configuration": {
          "chunk_shape": [
            1000,
            100
          ]
        }
      },
      "chunk_key_encoding": {
        "name": "default",
        "configuration": {
          "separator": "/"
        }
      },
      "fill_value": 0,
      "codecs": [
        {
          "name": "GZip",
          "configuration": {
            "level": 1
          }
        }
      ],
      "storage_transformers": null,
      "dimension_names": [
        "rows",
        "columns"
      ]
    }
  }
}
```

We can perform the same exercise for Zarr v.2.

```json
{
  "zarr_format" : 2,
  "attributes": {
    "foo" : 42, 
    "bar" : false
    },
  "members": {
    "foo": {
      "zarr_format" : 2,
      "shape" : [1000, 1000],
      "chunks": [100, 100],
      "dtype": "|u1",
      "compressor": null,
      "fill_value": 0,
      "order": "C",
      "dimension_separator":  "/",
      "filters": {},
      "attributes" : {
        "baz": true
        }
    }
  }
}
```

TODO: WOULD BE NICE TO HAVE AN EXAMPLE WITH MULTIPLE GROUPS AT THE SAME LEVEL

### Zarr Object Models in JSON schema

A ZOM can also be represented as a JSON schema. Here is a the ZOM for Zarr V3 expressed as a JSON schema:

```json
{
  "$defs": {
    "ArraySpec": {
      "additionalProperties": false,
      "description": "A model of a Zarr version 3 Array",
      "properties": {
        "zarr_format": {
          "const": 3,
          "default": 3,
          "title": "Zarr Format"
        },
        "node_type": {
          "const": "array",
          "default": "array",
          "title": "Node Type"
        },
        "attributes": {
          "default": {},
          "title": "Attributes",
          "type": "object"
        },
        "shape": {
          "items": {
            "type": "integer"
          },
          "title": "Shape",
          "type": "array"
        },
        "data_type": {
          "title": "Data Type",
          "type": "string"
        },
        "chunk_grid": {
          "$ref": "#/$defs/NamedConfig"
        },
        "chunk_key_encoding": {
          "$ref": "#/$defs/NamedConfig"
        },
        "fill_value": {
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "integer"
            },
            {
              "type": "number"
            },
            {
              "const": "Infinity"
            },
            {
              "const": "-Infinity"
            },
            {
              "const": "NaN"
            },
            {
              "type": "string"
            },
            {
              "maxItems": 2,
              "minItems": 2,
              "prefixItems": [
                {
                  "type": "number"
                },
                {
                  "type": "number"
                }
              ],
              "type": "array"
            },
            {
              "items": {
                "type": "integer"
              },
              "type": "array"
            }
          ],
          "title": "Fill Value"
        },
        "codecs": {
          "items": {
            "$ref": "#/$defs/NamedConfig"
          },
          "title": "Codecs",
          "type": "array"
        },
        "storage_transformers": {
          "anyOf": [
            {
              "items": {
                "$ref": "#/$defs/NamedConfig"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Storage Transformers"
        },
        "dimension_names": {
          "anyOf": [
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            {
              "type": "null"
            }
          ],
          "title": "Dimension Names"
        }
      },
      "required": [
        "shape",
        "data_type",
        "chunk_grid",
        "chunk_key_encoding",
        "fill_value",
        "codecs"
      ],
      "title": "ArraySpec",
      "type": "object"
    },
    "GroupSpec": {
      "additionalProperties": false,
      "properties": {
        "zarr_format": {
          "const": 3,
          "default": 3,
          "title": "Zarr Format"
        },
        "node_type": {
          "const": "group",
          "default": "group",
          "title": "Node Type"
        },
        "attributes": {
          "title": "Attributes",
          "type": "object"
        },
        "members": {
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#/$defs/GroupSpec"
              },
              {
                "$ref": "#/$defs/ArraySpec"
              }
            ]
          },
          "default": {},
          "title": "Members",
          "type": "object"
        }
      },
      "required": [
        "attributes",
        "members"
      ],
      "title": "GroupSpec",
      "type": "object"
    },
    "NamedConfig": {
      "additionalProperties": false,
      "properties": {
        "name": {
          "title": "Name",
          "type": "string"
        },
        "configuration": {
          "anyOf": [
            {
              "type": "object"
            },
            {
              "type": "null"
            }
          ],
          "title": "Configuration"
        }
      },
      "required": [
        "name",
        "configuration"
      ],
      "title": "NamedConfig",
      "type": "object"
    }
  },
  "allOf": [
    {
      "$ref": "#/$defs/GroupSpec"
    }
  ]
}
```

And likewise for Zarr V2:

```json
{
  "$ref": "#/definitions/Group",
  "definitions": {
    "Array": {
      "title": "Array",
      "description": "Model of a Zarr Version 2 Array",
      "type": "object",
      "properties": {
        "attributes": {
          "title": "Attributess",
          "type": "object"
        },
        "shape": {
          "title": "Shape",
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "chunks": {
          "title": "Chunks",
          "type": "array",
          "items": {
            "type": "integer"
          }
        },
        "dtype": {
          "title": "Dtype",
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "compressor": {
          "title": "Compressor",
          "type": "object"
        },
        "fill_value": {
          "title": "Fill Value"
        },
        "order": {
          "title": "Order",
          "enum": [
            "C",
            "F"
          ],
          "type": "string"
        },
        "filters": {
          "title": "Filters",
          "type": "array",
          "items": {
            "type": "object"
          }
        },
        "dimension_separator": {
          "title": "Dimension Separator",
          "enum": [
            ".",
            "/"
          ],
          "type": "string"
        },
        "zarr_version": {
          "title": "Zarr Version",
          "default": 2,
          "type": "integer"
        }
      },
      "required": [
        "attributess",
        "shape",
        "chunks",
        "dtype",
        "compressor",
        "order",
        "filters"
      ],
      "additionalProperties": false
    },
    "Group": {
      "title": "Group",
      "description": "Model of a Zarr Version 2 Group",
      "type": "object",
      "properties": {
        "attributes": {
          "title": "Attributes",
          "type": "object"
        },
        "members": {
          "title": "Members",
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#/definitions/Array"
              },
              {
                "$ref": "#/definitions/Group"
              }
            ]
          }
        },
        "zarr_version": {
          "title": "Zarr Version",
          "default": 2,
          "type": "integer"
        }
      },
      "required": [
        "attributes",
        "members"
      ],
      "additionalProperties": false
    }
  }
}
```

To facilitate adoption of new Zarr versions, it may be desirable to define a mapping from ZOM to ZOM, e.g. ZOM for Zarr v2 -> ZOM for Zarr v3. Programs could use such mappings to execute programmatic conversions of hierarchies to newer Zarr versions.

### Implementing consolidated metadata via Zarr Object Models

The time required to traverse large, deeply-nested Zarr hierarchies stored on high-latency backends (e.g., cloud storage) can be onerous for applications that consume Zarr containers. One solution to this problem is to consolidate the metadata for each node or group in the hierarchy into a document stored at the root of the hierarchy.

### Validating Zarr Object Models

A key motivator for developing the ZOM was the need to *validate* Zarr hierarchies. Communities that use Zarr often define conventions for storing their particular data models in Zarr hierarchies, and often these conventions could be statically checked if there was a data model for the hierarchy that was amenable to static type checking. The ZOM satisfies this constraint. 

For example, consider the `xarray` model introduced earlier, which requires a key ("_ARRAY_DIMENSIONS") to be present in array metadata. If we define the ZOM for Zarr V2 as dataclasses, we can use the python type-checking tool `mypy` to statically check that a Zarr hierarchy complies with the `xarray` convention:

```python
from dataclasses import dataclass
from typing import Generic, TypeVar, Mapping, List, Any, Union

TAttrs = TypeVar('TAttrs')
TMember = TypeVar('TMember')

@dataclass
class GroupSpec(Generic[TAttrs, TMember]):
  zarr_version = 2
  attributes: TAttrs
  members: Mapping[str, TMember]

@dataclass
class ArraySpec(Generic[TAttrs]):
  zarr_version = 2
  attributes: TAttrs
  shape: List[int]
  dtype: str
  chunks: List[int]
  compressor: Any
  dimension_separator: Union[Literal["."], Literal["/"]]

@dataclass
class XAttrs:
  _ARRAY_DIMENSIONS: List[str]

XArraySpec = ArraySpec[XAttrs]
XGroupSpec = GroupSpec[Any, Union[XArray, GroupSpec]]

# this passes the type checker
valid = XGroupSpec(
    attributes={}, 
    members={
        'array_0': XArraySpec(
        shape=[10,10],
        attributes=XAttrs(_ARRAY_DIMENSIONS= ['a','b']),
        dtype='uint8',
        chunks=[10,10],
        compressor=None,
        dimension_separator='.')},
        )

# This fails type checking because of the mssing _ARRAY_DIMENSIONS array attribute
invalid = XGroupSpec(
    attributes={}, 
    members={
        'array_0': XArraySpec(
        shape=[10,10],
        attributes={'foo': 10},
        dtype='uint8',
        chunks=[10,10],
        compressor=None,
        dimension_separator='/')},
        )
"""
Argument "attributes" to "ArraySpec" has incompatible type "dict[str, int]"; expected "XAttrs"
"""
```

The same result is possible in TypeScript:

```typescript

type GroupSpec<TAttr, TMember> = {
  zarr_version: 2
  attributes: TAttr
  members: {[key: string]: TMember}
}

type ArraySpec<TAttr> = {
  zarr_version: 2
  attributes: TAttr
  shape: number[]
  chunks: number[]
  dtype: string
  compressor: any
  dimension_separator: "." | "/"
}

type XAttrs = {
  _ARRAY_DIMENSIONS: string[]
}

type XArraySpec = ArraySpec<XAttrs>
type XGroupSpec = GroupSpec<any, XArraySpec>

const valid: XGroupSpec = {
  zarr_version: 2,
  attributes: {},
  members: {
    'array_0': {
      zarr_version: 2,
      dtype: 'uint8',
      attributes: {'_ARRAY_DIMENSIONS': ['a', 'b']},
      shape: [10, 10],
      chunks: [10, 10],
      compressor: undefined,
      dimension_separator: "/"
      }
    }
  }

// This fails type checking because of the mssing _ARRAY_DIMENSIONS array attribute
  const invalid: XGroupSpec = {
  zarr_version: 2,
  attributes: {},
  members: {
    'array_0': {
      zarr_version: 2,
      dtype: 'uint8',
      attributes: {'foo': ['a', 'b']},
      shape: [10, 10],
      chunks: [10, 10],
      compressor: undefined,
      dimension_separator: "/"
      }
    }
  }
/*
Type '{ foo: string[]; }' is not assignable to type 'XAttrs'.
  Object literal may only specify known properties, and ''foo'' does not exist in type 'XAttrs'.(2322)
*/
```

Static type checking on ZOM data structures offers an additional level of safety for applications that manipulate structured Zarr hierarchies, but not every invariant of a structured hierarchy can be expressed statically -- consider the constraint "the length of the `_ARRAY_DIMENSIONS` attribute must match the length of the `shape` attribute". This is not statically checkable, because the shape of an array may not be known before runtime. Such value-dependent validation can be added by runtime type checkers like `pydantic` for python, or `zod` for TypeScript.


## Related Work
  


## Implementation

- pydantic zarr
- ? 

## Discussion

- todo: show that consolidated metadata can be achieved by applying a flattening transformation to a ZOM representation of a hierarchy.
- - The origins of consolidated metadata:
    * <https://github.com/pangeo-data/pangeo/issues/309>
    * <https://github.com/zarr-developers/zarr-python/pull/268>


## References and Footnotes

[^1]: https://github.com/zarr-developers/geozarr-spec
[^2]: http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/ome/ngff/master/0.4/index.bs#multiscale-md
## License

<p xmlns:dct="http://purl.org/dc/terms/">
  <a rel="license"
     href="http://creativecommons.org/publicdomain/zero/1.0/">
    <img src="https://licensebuttons.net/p/zero/1.0/80x15.png" style="border-style: none;" alt="CC0" />
  </a>
  <br />
  To the extent possible under law,
  <a rel="dct:publisher"
     href="https://github.com/zarr-developers/zeps">
    <span property="dct:title">the authors</span></a>
  have waived all copyright and related or neighboring rights to
  <span property="dct:title">ZEP 1</span>.
</p>
